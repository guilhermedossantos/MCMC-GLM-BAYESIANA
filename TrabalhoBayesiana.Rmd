---
title: "Trabalho de Bayesiana"
subtitle: "Ajuste de modelo linear generalizado usando método de monte carlo via cadeias de markov"
date: "01 de julho de 2019"
author: "Guilherme dos Santos & Isabelle da Costa Oliveira"
output: html_notebook
---

```{r include=FALSE}
knitr::opts_knit$set(root.dir = "C:\\Users\\ibge\\Downloads\\Bayesiana\\MCMC-GLM-BAYESIANA-master")
library(coda)


#load("covergiu_6mi.RData")
```

#Algotitmo de Gibbs usando Metropolis-Hasting para gerar condicionais completas

## Dados
```{r}
#dados
n <- 13

x <- 1:13
y <- c(12, 14, 33, 50, 67, 74, 123, 141, 165, 204, 253, 246, 240)
```

## Estimativa clássica 

### Estimativa pontual
```{r}
modelo <- glm(y ~ x, family = poisson)
summary(modelo)
```

### Intervalos de confiança
```{r}
confint(modelo)
```

## Algoritmos

```{r}
#número de iterações
N <- 3*10^6

#variância da distribuição a priori proposta
k <- 200

#contadores 
cont_b1 <- 0
cont_b2 <- 0
cont_b3 <- 0

#núcleos das condicionais completas (vamos usar o logaritomos por problemas numéricos)
# cc_b1 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(-b1*(13 + (b1/(2*k))))}
# 
# cc_b2 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(- b2*(91 + (b2/(2*k))))}
# 
# cc_b3 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(- b3*(819 + (b3/(2*k))))}

cc_b1 <- function(b1, b2){sum(y*(b1 + b2*x)) - sum(exp(b1 + b2*x)) + ((-1/(2*k))*(b1^2))}
cc_b2 <- function(b1, b2){sum(y*(b1 + b2*x)) - sum(exp(b1 + b2*x)) + ((-1/(2*k))*(b2^2))}


```

```{r}
#valores iniciais
b1_am <- b2_am <- b3_am <- rep(NA, N)
b1_am[1] <- b2_am[1] <- 2

for(i in 2:N){
    
     #metropolis para b1
     b1 <- rnorm(1, b1_am[i-1], 2) 
     alpha <- min(0, 
                  cc_b1(b1, b2_am[i-1]) - cc_b1(b1_am[i-1], b2_am[i-1]))
     
     if(log(runif(1)) < alpha){
       b1_am[i] <- b1 
       cont_b1 <- cont_b1+1
     }else{
         b1_am[i] <- b1_am[i-1]
         }  
     
     #metropolis para b2
     b2 <- rnorm(1, b2_am[i-1], 1)
     alpha2 <- min(0, 
                   cc_b2(b1_am[i], b2) - cc_b2(b1_am[i], b2_am[i-1]))
     
     if(log(runif(1)) < alpha2){
       b2_am[i] <- b2
       cont_b2 <- cont_b2+1
     }else{
         b2_am[i] <- b2_am[i-1]
         }  
  
}

#save.image("convergiu_6mi.RData")
```

## Verificando convergência 

#### $\beta_1$
```{r}

plot(b1_am, type = "l", lwd = 2, main = expression(beta[1]))
#abline(a = b1, b = 0, col = 2)

cont_b1/N
```

#### $\beta_2$
```{r}
plot(b2_am, type = "l", lwd = 2, main = "Cadeia de b2")
#abline(a = b2, b = 0, col = 2)

cont_b2/N
```

#### $\beta_3$
```{r}
# plot(b3_am, type = "l", main = "Cadeia de b3")
# #abline(a = b3, b = 0, col = 2)
# 
# cont_b3/N
```

## Tratamento da cadeia
```{r}
burnin <- 200000
b1_2 <- b1_am[(burnin + 1):N]
b2_2 <- b2_am[(burnin + 1):N]
#b3_2 <- b3_am[(burnin + 1):N]
```


```{r}
plot(b1_2, type = "l", lwd = 2)
```


```{r}
plot(b2_2, type = "l", lwd = 2)
```

```{r}
thin <- 560
b1_2<-b1_2[seq(1,length(b1_2),by=thin)]
b2_2<-b2_2[seq(1,length(b2_2),by=thin)]

```

```{r}
acf(b1_2)
```

```{r}
coda::raftery.diag(b1_2)
```

```{r}
coda:: raftery.diag(b2_2)
```

## Estimativas pontuais

b1
```{r}
mean(b1_2)
median(b1_2)
(b1_2_1modeda <- as.numeric(names(which.max(table(b1_2)))))
```

b2
```{r}
mean(b2_2)
median(b2_2)
(b2_2_1moda <- as.numeric(names(which.max(table(b2_2)))))
```

```{r}
mean(b3_2)
median(b3_2)
(b2_3_1moda <- as.numeric(names(which.max(table(b3_2)))))
```


```{r}
HPDinterval(as.mcmc(b1_2))
```

```{r}
HPDinterval(as.mcmc(b2_2))
```

## Distribuições a posteriori
```{r}
## olahr do m10 exs gibbs COLEI LOGO AQUI KK
# par(mfrow=c(1,3))
# hist(b1_2,prob=T,ylab="",xlab="",main=expression(beta[1]))
# abline(v=beta0_v,col=2,lty=2,lwd=3)
# points(media_beta0,0,col=3,lwd=4)
# points(HPD_beta0[1],0,col=3,lwd=4)
# points(HPD_beta0[2],0,col=3,lwd=4)
# 
# hist(beta1,prob=T,ylab="",xlab="",main=expression(beta[1]))
# abline(v=beta1_v,col=2,lty=2,lwd=3)
# points(media_beta1,0,col=3,lwd=4)
# points(HPD_beta1[1],0,col=3,lwd=4)
# points(HPD_beta1[2],0,col=3,lwd=4)
# 
# hist(phi,prob=T,ylab="",xlab="",main=expression(phi))
# abline(v=phi_v,col=2,lty=2,lwd=3)
# points(media_phi,0,col=3,lwd=4)
# points(HPD_phi[1],0,col=3,lwd=4)
# points(HPD_phi[2],0,col=3,lwd=4)
```

