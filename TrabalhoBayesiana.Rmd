---
title: "Trabalho de Bayesiana"
subtitle: "Ajuste de modelo linear generalizado usando método de monte carlo via cadeias de markov"
date: "01 de julho de 2019"
author: "Guilherme dos Santos & Isabelle da Costa Oliveira"
output: html_notebook
---
#Algotitmo de Gibbs usando Metropolis-Hasting para gerar condicionais completas

## FDados
```{r}
#dados
n <- 13

x <- 1:13
y <- c(12, 14, 33, 50, 67, 74, 123, 141, 165, 204, 253, 246, 240)
```

## Algoritmos

```{r}
#número de iterações
N <- 10000

#variância da distribuição a priori proposta
k <- 200

#contadores 
cont_b1 <- 0
cont_b2 <- 0
cont_b3 <- 0

#núcleos das condicionais completas (vamos usar o logaritomos por problemas numéricos)
# cc_b1 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(-b1*(13 + (b1/(2*k))))}
# 
# cc_b2 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(- b2*(91 + (b2/(2*k))))}
# 
# cc_b3 <- function(b1,b2,b3){prod(b1 + b2*x + b3*x^2)*exp(- b3*(819 + (b3/(2*k))))}


cc_b1 <- function(b1,b2,b3){sum(y*(b1 + b2*x + b3*x^2)) - sum(exp(b1 + b2*x + b3*x^2)) - b1/(2*k)}

cc_b2 <- function(b1, b2, b3){sum(y*(b1 + b2*x + b3*x^2)) - sum(exp(b1 + b2*x + b3*x^2)) - b2/(2*k)}

cc_b3 <- function(b1,b2,b3){sum(y*(b1 + b2*x + b3*x^2)) - sum(exp(b1 + b2*x + b3*x^2)) - b3/(2*k)}

```

```{r}
#valores iniciais
b1_am <- b2_am <- b3_am <- rep(NA, N)
b1_am[1] <- b2_am[1] <- b3_am[1] <- 3

for(i in 2:N){
    
     #metropolis para b1
     b1 <- rnorm(1,b1_am[i-1],k) #Usando a normal como distribuição proposta, passei aleatorio 
     alpha <- min(0, cc_b1(b1, b2_am[i-1], b3_am[i-1]) - cc_b1(b1_am[i-1], b2_am[i-1], b3_am[i-1]))
     if(log(runif(1)) < alpha){b1_am[i] <- b1;cont_b1 <- cont_b1+1}else{b1_am[i] <- b1_am[i-1]}  
     
     #metropolis para b2
     b2 <- rnorm(1,b2_am[i-1],k) 
     alpha2 <- min(0, cc_b2(b1_am[i], b2, b3_am[i-1]) - cc_b2(b1_am[i], b2_am[i-1], b3_am[i-1]))
     if(log(runif(1)) < alpha2){b2_am[i] <- b2;cont_b2 <- cont_b2+1}else{b2_am[i] <- b2_am[i-1]}  
      
     #metropolis para b3
     b3 <- rnorm(1, b3_am[i-1], k) 
     alpha3 <- min(0, cc_b3(b1_am[i], b2_am[i], b3) - cc_b3(b1_am[i], b2_am[i], b3_am[i-1]))
     if(log(runif(1)) < alpha3){b3_am[i] <- b3;cont_b3 <- cont_b3+1}else{b3_am[i] <- b3_am[i-1]}  
  }
```

## Verificando convergência 

#### $\beta_1$
```{r}
b1 <- 1
b2 <- 1
b3 <- 1
plot(b1_am[1:N], type = "l", ylim=c(0,10))
abline(a = b1, b = 0, col = 2)

cont_b1/N
```

#### $\beta_2$
```{r}
ts.plot(b2_am[1:N], ylim=c(0,5))
abline(a = b2, b = 0, col = 2)

cont_b2/N
```

#### $\beta_3$
```{r}
ts.plot(b3_am[1:N])
abline(a = b3, b = 0, col = 2)

cont_b3/N
```

#Algoritmo de Metropolis-Hasting

